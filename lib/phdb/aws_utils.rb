
require 'iconv'

module AWSUtils

  def get_HT_namespace_list()
    namespace_list = %w(bc nnc1 nnc2 coo dul1 gri hvd inu loc nyp ncs1 
                        ien pst psia njp pur1 pur2 ucm uc1 uc2 chi uiug
                        uiuo mdp miua miun umn mdl nc01 pitt uva wu usu 
                        yale)
  end


  ### encapsulates data from a row of output of the "membermap2.pig" 
  #   script.   ###
  class MemberMapRecord
    attr_accessor :oclc, :member_ids, :local_ids, :types
    
    def initialize(oclc)
      @oclc = oclc
      @member_ids = []
      @local_ids = []
      @types = []
    end

    def add_to_member_ids(string_obj)
      raise "object must be a String" unless string_obj.kind_of? String
      @member_ids.push(string_obj)
    end
    
    def add_to_local_ids(string_obj)
      raise "object must be a String" unless string_obj.kind_of? String
      @local_ids.push(string_obj.strip)
    end
    
    def add_to_types(string_obj)
      raise "object must be a String" unless string_obj.kind_of? String
      @types.push(string_obj)
    end
    
    def get_HT_local_ids()
      ids = []
      ht_ns = get_HT_namespace_list()
      ids.each do |id|
        ns = id.split('.')[0]
        ids << ns if ht_ns.include?(ns) 
      end
      return ids
    end
    
    def to_s()
      pretty_mids = @member_ids.join(',')
      pretty_lids = @local_ids.join(',')
      pretty_types = @types.join(',')
      outline = "#{@oclc}\t[#{pretty_mids}]\t[#{pretty_lids}]\t[#{pretty_types}]"
    end
  end
  ### end class MemberMapRecord ###
  
  ### main parser for a record generated by the 'membermap' AWS pig script ###
  def parse_record(row)
    row = row.strip
    row = row.gsub!(/\(/, '')
    row = row.gsub!(/\)/, '')
    bits = row.split("\t")
    bits.map{ |item| item.strip}
    bits.map{ |item| item.gsub!(/\{/, '') }
    bits.map{ |item| item.gsub!(/\}/, '') }
    ocn = bits[0]
    record = MemberMapRecord.new(ocn)
    if (ocn==nil or bits[1]==nil or bits[2]==nil or bits[3]==nil)
      puts "Bad record: '#{row}'"
      return nil
    end
    bits[1].split(',').each do |mi|
      record.add_to_member_ids(mi)
    end
    bits[2].split(',').each do |li|
      record.add_to_local_ids(li)
    end
    bits[3].split(',').each do |t|
      record.add_to_types(t)
    end
    return record
  end
  
  
  def clean_data(infilen, outfilen)
    count = 0
    f = File.open(infilen, "r")
    outf = File.open(outfilen, "w")
    outf.puts("OCN\tMEMBER_IDS\tLOCAL_IDS\tTYPES\n")
    f.each_line { |line|
      record = parse_record(line)
      next if record == nil
      outf.puts(record.to_s)
      count += 1
      puts count if count % 100000 == 0
    }
    puts "\n#{count} lines parsed."
    outf.close
    f.close
  end    
  
  
end
